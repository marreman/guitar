{"version":3,"sources":["../node_modules/pitchfinder/lib/detectors/amdf.js","../node_modules/pitchfinder/lib/detectors/yin.js","../node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js","../node_modules/pitchfinder/lib/detectors/macleod.js","../node_modules/pitchfinder/lib/tools/frequencies.js","../node_modules/pitchfinder/lib/index.js","../node_modules/pitchfinder/index.js","../node_modules/process/browser.js","audio.js","index.js"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","Pitchfinder","require","detectPitch","AMDF","lastFrequency","onFrequencyChange","f","stream","navigator","mediaDevices","getUserMedia","audio","context","window","AudioContext","analyser","createAnalyser","processor","createScriptProcessor","audioSource","createMediaStreamSource","event","frequency","inputBuffer","getChannelData","connect","destination","addEventListener","removeEventListener","getTracks","forEach","track","stop","disconnect","close","Elm","app","Main","init","flags","node","document","querySelector","ports","startListeningForFrequencyChanges","subscribe","send","stopListeningForFrequencyChanges","then"],"mappings":"AMAA,ANAA,AEAA,ACAA,AFAA,AIAA,ADAA,AKAA,MAAM;ATCN,AEAA,ACAA,AFAA,AIAA,ADAA,AGDA,ACAA,ACAQgE,EAAAA,IDAFL,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;AREA,AEAA,ACAA,AFAA,AIAA,ADAA,AGDA,AEDM,IFCF5D,AED0B4D,OFCnB,AED0B,CAAC,EFCxB3D,MAAM,CAACC,AEDgB,CAArC,MFCc,GAAiB,EAA/B,EAEA;APAA,AEAA,ACAA,AFAA,AIAA,ADAA,AGCA,ACHA,MAAM2D,WAAW,GAAGF,WAAW,CAACG,IAAZ,EAApB;ARGA,AEAA,ACAA,AFAA,AIAA,ADAA,AGCA,ACFA,ACFA,IDEIC,ECFE,WDEW,GAAG,IAApB;AREA,AEAA,ACAA,AFAA,AIAA,ADAA,AGCA,AELQ+B,EAAAA;ATKR,AEAA,ACAA,AFAA,AIAA,ADAA,AIDA5F,ACJM,IAAU0D,GDIT,CAACI,GCJe,CAAC,YAAD,CDIvB,ACJA,GDI4B,MAAMC,CAAN,IAAW;AREvC,AEAA,ACAA,AFAA,AIAA,ADAA,AGCA,ACFE,IDEE9D,ICFI+D,MAAM,GAAG,GDEjB,GCFuBC,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;ARE3D,AEAA,ACAA,AFAA,AIAA,ADAA,AGCA,ACH6DC,ACH7D,IFMIlE,ACHyDkE,ECHvDyB,GDG4D,ACHzD,EDG2D,CCHxDD,GAAG,CAACE,IAAJ,CAASC,CFMrB,GENY,CAAc;ATM1B,AEAA,ACAA,AFAA,AIAA,ADAA,AIH2D,ACFzDC,EAAAA,CDEqB,CAArB,GCFK,EAAE,EADiB;ATO1B,AEAA,ACAA,AFAA,AIAA,ADAA,AGCA,ACJE,ACFAC,EAAAA,IAAI,EDEE5B,ACFA6B,CFMC/F,MCJM,CCFC,CAACgG,CDEC,IAAI7B,GDItB,GAA4B,ACJA,CAACC,CCFrB,CAAuB,UDEb,ACFV,EDEN;ARIF,AEAA,ACAA,AFAA,AIAA,ADAA,AGCI,ACJF,ACLwB,CAAd,CAAZ,MFSU,ACJFC,IDIMpE,ICJE,CDIN,CAAU,CCJDiE,OAAO,CAACI,cAAR,EAAjB,QDIQ,CAAN;APAJ,AEAA,ACAA,AFAA,AIAA,ADAA,AGCC,ACJC,ACDF,IAAIL,IDCIM,CCDR,QDCiB,GAAGL,OAAO,CAACM,qBAAR,CAA8B,IAA9B,EAAoC,CAApC,EAAuC,CAAvC,CAAlB;ARIF,AEAA,ACAA,AFAA,AIAA,ADAA,AIHE,ACAFkB,GAAG,CAACO,IDAIxB,CCAR,CAAUyB,SDAS,GAAGhC,OAAO,CAACQ,aCA9B,CAA4CyB,SDAtB,ACAtB,CDAsDtC,ACAA,MDAhC,ACAsC,CDA1D;ARIF,AEAA,ACAA,AFAA,AIAA,ADAA,AGAA,AEHEI,EAAAA,KAAK,EFGE/D,CEHCyD,iBAAiB,CFG3B,AEH4BiB,GFGI,MEHK,IAAI;ATIzC,AEAA,ACAA,AFAA,AIAA,ADAA,AGAI,ACJF,ACCEc,IAAAA,GAAG,CFGG,ACJF/F,ACCAsG,IFGMhG,CEHV,CAAU0D,CDDC,EDIL,CAAU,ACJFgB,KAAK,IAAI,ICCvB,CAA4ByB,IAA5B,CAAiCxB,SAAjC,OFGM,CAAN;APCJ,AEAA,ACAA,AFAA,AGAA,AGAC,ACJG,ACCD,GAFwB,CAAzB,MDCQA,SAAS,GAAGpB,WAAW,CAACmB,KAAK,CAACE,WAAN,CAAkBC,cAAlB,CAAiC,CAAjC,CAAD,CAA7B;ARKJ,AEAA,ACAA,AFAA,AGAA,AKHC,CAJD;ATQA,AEAA,ACAA,AFAA,AGAA,AGDC,ACHG,ACEJY,GAAG,CAACO,IDFIrB,CCER,CAAUyB,GFCG,ICHI,KAAK3C,aAAlB,EAAiC,KCErC,CAA2CyC,SAA3C,CAAqD,MAAM;ATG3D,AEAA,ACAA,AFAA,AGAA,AGDI,ACHEzC,ACEJO,EAAAA,IFCM,ACHFP,CCEC,IAAIO,KAAK,CAACqC,EDFE,ECER,CDFW1B,ACEAW,SDFhB,CCE0B,IAAIA,UAAU,EAAnC,CAAT;ATGF,AEAA,ACAA,AFAA,AGAA,AGDQ,ACHF3B,ACEL,CAFD,KDAMA,CAAC,CDGK,ACHJgB,ODGWzE,ECHZ,CAAD,ODGM,KAAsB,UAA1B,EAAsC;APE9C,AEAA,ACAA,AFAA,AGAA,AGDYL,ACHP,MDGOA,gBAAgB,GAAGK,UAAnB;APEZ,AEAA,ACAA,AFAA,AGAA,AGDS,ACHN,GAPD,EDQM,MAEO;APEf,AEAA,ACAA,AFAA,AGAA,AGDYL,MAAAA,gBAAgB,GAAGE,gBAAnB;APEZ,AEAA,ACAA,AFAA,AGAA,AGDS,ACHPyE,EAAAA,WAAW,CAACM,OAAZ,CAAoBV,QAApB;ARKF,AEAA,ACAA,AFAA,AGAA,AGDK,ACHHA,EAAAA,CDHE,CAME,MCHI,CDGGjE,ACHF2E,CDGL,EAAU,ICHd,CAAiBR,SAAjB;ARKF,AEAA,ACAA,AFAA,AGAA,AGDQzE,ACHNyE,EAAAA,EDGMzE,OCHG,CAACiF,OAAV,CDGsB,ACHJb,GDGOlE,ICHA,CAACgF,WDGpB,ACHN;ARKF,AEAA,ACAA,AFAA,AGAA,AGDK,ACHHT,EAAAA,SAAS,CAACU,gBAAV,CAA2B,cAA3B,EAA2CtF,OAA3C;ARKF,AEAA,ACAA,AFAA,AGAA,AIHE,SAAO,MAAM;ARIf,AEAA,ACAA,AFAA,AGAA,AGFI,ACDA4E,IAAAA,EDCI,OCDK,CAACW,mBAAV,CAA8B,cAA9B,EAA8CvF,OAA9C;ARIJ,AEAA,ACAA,AFAA,AGAA,AGFQ,ACDJkE,IAAAA,IDCQ,ECDF,CAACsB,IDCQ9E,KCDf,GAAmB+E,IDCX,GCDR,CAA2BC,CDCK,ICDA,IAAIA,EDChC,EAAwC,CCDH,CAACC,IAAN,EAApC;ARIJ,AEAA,ACAA,AFAA,AGAA,AGFYvF,ACDRwE,IAAAA,EDCQxE,OCDC,CAACwF,UDCgB,ACD1B,GDC6BlF,YAArB;APGZ,AEAA,ACAA,AFAA,AGAA,AGFS,ACDLgE,IAAAA,CDDI,MAEO,CCDH,CAACkB,UAAT;ARIJ,AEAA,ACAA,AFAA,AGAA,AGFYxF,ACDR0E,IAAAA,EDCQ1E,SCDG,CAACwF,QDCc,ECD1B,CDC6BrF,mBAArB;APGZ,AEAA,ACAA,AFAA,AGAA,AGFS,ACDLgE,IAAAA,OAAO,CAACsB,KAAR;ARIJ,AEAA,ACAA,AFAA,AGAA,AGFK,ACDF,GDLC,ACFF,CDQI,OAAOpF,CAAP,EAAU;APGhB,AEAA,ACAA,AFAA,AGAA,AGFQL,ACDP,CA5BD,GD6BQA,kBAAkB,GAAGG,mBAArB;APGR,AEAA,ACAA,AFAA,AGAA,AGFK;APGL,AEAA,ACAA,AFAA,AGAA,AGFC,CAnBA,GAAD;APsBA,AEAA,ACAA,AFAA,AGAA;AJCA,AEAA,ACAA,AFAA,AGAA,AGHA,SAASI,UAAT,CAAoBC,GAApB,EAAyB;APIzB,AEAA,ACAA,AFAA,AGAA,AGHI,MAAIT,gBAAgB,KAAKK,UAAzB,EAAqC;APIzC,AEAA,ACAA,AFAA,AGAA,AGHQ;APIR,AEAA,ACAA,AFAA,AGAA,AGHQ,WAAOA,UAAU,CAACI,GAAD,EAAM,CAAN,CAAjB;APIR,AEAA,ACAA,AFAA,AGAA,AGHK,GAJoB,CAKrB;APGJ,AEAA,ACAA,AFAA,AGAA;AJCA,AEAA,ACAA,AFAA,AGAA;AJCA,AEAA,ACAA,AFAA,AGAA,AGJI,MAAI,CAACT,gBAAgB,KAAKE,gBAArB,IAAyC,CAACF,gBAA3C,KAAgEK,UAApE,EAAgF;APKpF,AEAA,ACAA,AFAA,AGAA,AGJQL,IAAAA,gBAAgB,GAAGK,UAAnB;APKR,AEAA,ACAA,AFAA,AGAA,AGJQ,WAAOA,UAAU,CAACI,GAAD,EAAM,CAAN,CAAjB;APKR,AEAA,ACAA,AFAA,AGAA,AGJK;APKL,AEAA,ACAA,AFAA,AGAA;AJCA,AEAA,ACAA,AFAA,AGAA,AGLI,MAAI;APMR,AEAA,ACAA,AFAA,AGAA,AGLQ;APMR,AEAA,ACAA,AFAA,AGAA,AGLQ,WAAOT,gBAAgB,CAACS,GAAD,EAAM,CAAN,CAAvB;APMR,AEAA,ACAA,AFAA,AGAA,AGLK,GAHD,CAGE,OAAMH,CAAN,EAAQ;APMd,AEAA,ACAA,AFAA,AGAA,AGLQ,QAAI;APMZ,AEAA,ACAA,AFAA,AGAA,AGLY;APMZ,AEAA,ACAA,AFAA,AGAA,AGLY,aAAON,gBAAgB,CAACU,IAAjB,CAAsB,IAAtB,EAA4BD,GAA5B,EAAiC,CAAjC,CAAP;APMZ,AEAA,ACAA,AFAA,AGAA,AGLS,KAHD,CAGE,OAAMH,CAAN,EAAQ;APMlB,AEAA,ACAA,AFAA,AGAA,AGLY;APMZ,AEAA,ACAA,AFAA,AGAA,AGLY,aAAON,gBAAgB,CAACU,IAAjB,CAAsB,IAAtB,EAA4BD,GAA5B,EAAiC,CAAjC,CAAP;APMZ,AEAA,ACAA,AFAA,AGAA,AGLS;APMT,AEAA,ACAA,AFAA,AGAA,AGLK;APML,AEAA,ACAA,AFAA,AGAA,AGHC;APID,AEAA,ACAA,AFAA,AGAA;AJCA,AEAA,ACAA,AFAA,AGAA,AGJA,SAASE,eAAT,CAAyBC,MAAzB,EAAiC;APKjC,AEAA,ACAA,AFAA,AGAA,AGJI,MAAIX,kBAAkB,KAAKM,YAA3B,EAAyC;APK7C,AEAA,ACAA,AFAA,AGAA,AGJQ;APKR,AEAA,ACAA,AFAA,AGAA,AGJQ,WAAOA,YAAY,CAACK,MAAD,CAAnB;APKR,AEAA,ACAA,AFAA,AGAA,AGJK,GAJ4B,CAK7B;APIJ,AEAA,ACAA,AFAA;ADCA,AEAA,ACAA,AFAA;ADCA,AEAA,ACAA,AFAA,AMLI,MAAI,CAACX,kBAAkB,KAAKG,mBAAvB,IAA8C,CAACH,kBAAhD,KAAuEM,YAA3E,EAAyF;APM7F,AEAA,ACAA,AFAA,AMLQN,IAAAA,kBAAkB,GAAGM,YAArB;APMR,AEAA,ACAA,AFAA,AMLQ,WAAOA,YAAY,CAACK,MAAD,CAAnB;APMR,AEAA,ACAA,AFAA,AMLK;APML,AEAA,ACAA,AFAA;ADCA,AEAA,ACAA,AFAA,AMNI,MAAI;APOR,AEAA,ACAA,AFAA,AMNQ;APOR,AEAA,ACAA,AFAA,AMNQ,WAAOX,kBAAkB,CAACW,MAAD,CAAzB;APOR,AEAA,ACAA,AFAA,AMNK,GAHD,CAGE,OAAON,CAAP,EAAS;APOf,AEAA,ACAA,AFAA,AMNQ,QAAI;APOZ,AEAA,ACAA,AFAA,AMNY;APOZ,AEAA,ACAA,AFAA,AMNY,aAAOL,kBAAkB,CAACS,IAAnB,CAAwB,IAAxB,EAA8BE,MAA9B,CAAP;APOZ,AEAA,ACAA,AFAA,AMNS,KAHD,CAGE,OAAON,CAAP,EAAS;APOnB,AEAA,ACAA,AFAA,AMNY;APOZ,AEAA,ACAA,AFAA,AMNY;APOZ,AEAA,ACAA,AFAA,AMNY,aAAOL,kBAAkB,CAACS,IAAnB,CAAwB,IAAxB,EAA8BE,MAA9B,CAAP;APOZ,AEAA,ACAA,AFAA,AMNS;APOT,AEAA,ACAA,AFAA,AMNK;APOL,AEAA,ACAA,AFAA,AMHC;ALID,ACAA,AFAA;ACCA,ACAA,AFAA,AMJA,IAAIC,KAAK,GAAG,EAAZ;ALKA,ACAA,AFAA,AMJA,IAAIC,QAAQ,GAAG,KAAf;ALKA,ACAA,AFAA,AMJA,IAAIC,YAAJ;ALKA,ACAA,AFAA,AMJA,IAAIC,UAAU,GAAG,CAAC,CAAlB;ALKA,ACAA,AFAA;ACCA,ACAA,AFAA,AMJA,SAASC,eAAT,GAA2B;ALK3B,ACAA,AFAA,AMJI,MAAI,CAACH,QAAD,IAAa,CAACC,YAAlB,EAAgC;ALKpC,ACAA,AFAA,AMJQ;ALKR,ACAA,AFAA,AMJK;ALKL,ACAA,AFAA;ACCA,ACAA,AFAA,AMLID,EAAAA,QAAQ,GAAG,KAAX;ALMJ,ACAA,AFAA;ACCA,ACAA,AFAA,AMNI,MAAIC,YAAY,CAACG,MAAjB,EAAyB;ALO7B,ACAA,AFAA,AMNQL,IAAAA,KAAK,GAAGE,YAAY,CAACI,MAAb,CAAoBN,KAApB,CAAR;ALOR,ACAA,AFAA,AMNK,GAFD,MAEO;ALOX,ACAA,AFAA,AMNQG,IAAAA,UAAU,GAAG,CAAC,CAAd;ALOR,ACAA,AFAA,AMNK;ALOL,ACAA,AFAA;ACCA,ACAA,AFAA,AMPI,MAAIH,KAAK,CAACK,MAAV,EAAkB;ALQtB,ACAA,AFAA,AMPQE,IAAAA,UAAU;ALQlB,ACAA,AFAA,AMPK;ALQL,ACAA,AFAA,AMPC;ALQD,ACAA,AFAA;ACCA,ACAA,AFAA,AMPA,SAASA,UAAT,GAAsB;ALQtB,ACAA,AFAA,AMPI,MAAIN,QAAJ,EAAc;ALQlB,ACAA,AFAA,AMPQ;ALQR,ACAA,AFAA,AMPK;ALQL,ACAA,AFAA;ACCA,ACAA,AFAA,AMRI,MAAIO,OAAO,GAAGb,UAAU,CAACS,eAAD,CAAxB;ALSJ,ACAA,AFAA,AMRIH,EAAAA,QAAQ,GAAG,IAAX;ALSJ,ACAA,AFAA,AMPI,MAAIQ,GAAG,GAAGT,KAAK,CAACK,MAAhB;ALQJ,ACAA,AFAA;ACCA,ACAA,AFAA,AMRI,SAAMI,GAAN,EAAW;ALSf,ACAA,AFAA,AMRQP,IAAAA,YAAY,GAAGF,KAAf;ALSR,ACAA,AFAA,AMRQA,IAAAA,KAAK,GAAG,EAAR;ALSR,ACAA,AFAA;ACCA,ACAA,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","file":"src.e31bb0bc.js","sourceRoot":"../src","sourcesContent":["\"use strict\";\n\nvar DEFAULT_MIN_FREQUENCY = 82;\nvar DEFAULT_MAX_FREQUENCY = 1000;\nvar DEFAULT_RATIO = 5;\nvar DEFAULT_SENSITIVITY = 0.1;\nvar DEFAULT_SAMPLE_RATE = 44100;\n\nmodule.exports = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n  var minFrequency = config.minFrequency || DEFAULT_MIN_FREQUENCY;\n  var maxFrequency = config.maxFrequency || DEFAULT_MAX_FREQUENCY;\n  var sensitivity = config.sensitivity || DEFAULT_SENSITIVITY;\n  var ratio = config.ratio || DEFAULT_RATIO;\n  var amd = [];\n\n  /* Round in such a way that both exact minPeriod as \n   exact maxPeriod lie inside the rounded span minPeriod-maxPeriod,\n   thus ensuring that minFrequency and maxFrequency can be found\n   even in edge cases */\n  var maxPeriod = Math.ceil(sampleRate / minFrequency);\n  var minPeriod = Math.floor(sampleRate / maxFrequency);\n\n  return function AMDFDetector(float32AudioBuffer) {\n    \"use strict\";\n\n    var maxShift = float32AudioBuffer.length;\n\n    var t = 0;\n    var minval = Infinity;\n    var maxval = -Infinity;\n    var frames1 = void 0,\n        frames2 = void 0,\n        calcSub = void 0,\n        i = void 0,\n        j = void 0,\n        u = void 0,\n        aux1 = void 0,\n        aux2 = void 0;\n\n    // Find the average magnitude difference for each possible period offset.\n    for (i = 0; i < maxShift; i++) {\n      if (minPeriod <= i && i <= maxPeriod) {\n        for (aux1 = 0, aux2 = i, t = 0, frames1 = [], frames2 = []; aux1 < maxShift - i; t++, aux2++, aux1++) {\n          frames1[t] = float32AudioBuffer[aux1];\n          frames2[t] = float32AudioBuffer[aux2];\n        }\n\n        // Take the difference between these frames.\n        var frameLength = frames1.length;\n        calcSub = [];\n        for (u = 0; u < frameLength; u++) {\n          calcSub[u] = frames1[u] - frames2[u];\n        }\n\n        // Sum the differences.\n        var summation = 0;\n        for (u = 0; u < frameLength; u++) {\n          summation += Math.abs(calcSub[u]);\n        }\n        amd[i] = summation;\n      }\n    }\n\n    for (j = minPeriod; j < maxPeriod; j++) {\n      if (amd[j] < minval) minval = amd[j];\n      if (amd[j] > maxval) maxval = amd[j];\n    }\n\n    var cutoff = Math.round(sensitivity * (maxval - minval) + minval);\n    for (j = minPeriod; j <= maxPeriod && amd[j] > cutoff; j++) {}\n\n    var search_length = minPeriod / 2;\n    minval = amd[j];\n    var minpos = j;\n    for (i = j - 1; i < j + search_length && i <= maxPeriod; i++) {\n      if (amd[i] < minval) {\n        minval = amd[i];\n        minpos = i;\n      }\n    }\n\n    if (Math.round(amd[minpos] * ratio) < maxval) {\n      return sampleRate / minpos;\n    } else {\n      return null;\n    }\n  };\n};","\"use strict\";\n\n/*\n  Copyright (C) 2003-2009 Paul Brossier <piem@aubio.org>\n  This file is part of aubio.\n  aubio is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  aubio is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n  along with aubio.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* This algorithm was developed by A. de Cheveigné and H. Kawahara and\n * published in:\n * \n * de Cheveigné, A., Kawahara, H. (2002) \"YIN, a fundamental frequency\n * estimator for speech and music\", J. Acoust. Soc. Am. 111, 1917-1930.  \n *\n * see http://recherche.ircam.fr/equipes/pcm/pub/people/cheveign.html\n */\n\nvar DEFAULT_THRESHOLD = 0.10;\nvar DEFAULT_SAMPLE_RATE = 44100;\nvar DEFAULT_PROBABILITY_THRESHOLD = 0.1;\n\nmodule.exports = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n  var threshold = config.threshold || DEFAULT_THRESHOLD;\n  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n  var probabilityThreshold = config.probabilityThreshold || DEFAULT_PROBABILITY_THRESHOLD;\n\n  return function YINDetector(float32AudioBuffer) {\n    \"use strict\";\n\n    // Set buffer size to the highest power of two below the provided buffer's length.\n\n    var bufferSize = void 0;\n    for (bufferSize = 1; bufferSize < float32AudioBuffer.length; bufferSize *= 2) {}\n    bufferSize /= 2;\n\n    // Set up the yinBuffer as described in step one of the YIN paper.\n    var yinBufferLength = bufferSize / 2;\n    var yinBuffer = new Float32Array(yinBufferLength);\n\n    var probability = void 0,\n        tau = void 0;\n\n    // Compute the difference function as described in step 2 of the YIN paper.\n    for (var t = 0; t < yinBufferLength; t++) {\n      yinBuffer[t] = 0;\n    }\n    for (var _t = 1; _t < yinBufferLength; _t++) {\n      for (var i = 0; i < yinBufferLength; i++) {\n        var delta = float32AudioBuffer[i] - float32AudioBuffer[i + _t];\n        yinBuffer[_t] += delta * delta;\n      }\n    }\n\n    // Compute the cumulative mean normalized difference as described in step 3 of the paper.\n    yinBuffer[0] = 1;\n    yinBuffer[1] = 1;\n    var runningSum = 0;\n    for (var _t2 = 1; _t2 < yinBufferLength; _t2++) {\n      runningSum += yinBuffer[_t2];\n      yinBuffer[_t2] *= _t2 / runningSum;\n    }\n\n    // Compute the absolute threshold as described in step 4 of the paper.\n    // Since the first two positions in the array are 1,\n    // we can start at the third position.\n    for (tau = 2; tau < yinBufferLength; tau++) {\n      if (yinBuffer[tau] < threshold) {\n        while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n          tau++;\n        }\n        // found tau, exit loop and return\n        // store the probability\n        // From the YIN paper: The threshold determines the list of\n        // candidates admitted to the set, and can be interpreted as the\n        // proportion of aperiodic power tolerated\n        // within a periodic signal.\n        //\n        // Since we want the periodicity and and not aperiodicity:\n        // periodicity = 1 - aperiodicity\n        probability = 1 - yinBuffer[tau];\n        break;\n      }\n    }\n\n    // if no pitch found, return null.\n    if (tau == yinBufferLength || yinBuffer[tau] >= threshold) {\n      return null;\n    }\n\n    // If probability too low, return -1.\n    if (probability < probabilityThreshold) {\n      return null;\n    }\n\n    /**\n     * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n     * value using parabolic interpolation. This is needed to detect higher\n     * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n     * for more background\n     * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n     */\n    var betterTau = void 0,\n        x0 = void 0,\n        x2 = void 0;\n    if (tau < 1) {\n      x0 = tau;\n    } else {\n      x0 = tau - 1;\n    }\n    if (tau + 1 < yinBufferLength) {\n      x2 = tau + 1;\n    } else {\n      x2 = tau;\n    }\n    if (x0 === tau) {\n      if (yinBuffer[tau] <= yinBuffer[x2]) {\n        betterTau = tau;\n      } else {\n        betterTau = x2;\n      }\n    } else if (x2 === tau) {\n      if (yinBuffer[tau] <= yinBuffer[x0]) {\n        betterTau = tau;\n      } else {\n        betterTau = x0;\n      }\n    } else {\n      var s0 = yinBuffer[x0];\n      var s1 = yinBuffer[tau];\n      var s2 = yinBuffer[x2];\n      // fixed AUBIO implementation, thanks to Karl Helgason:\n      // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n      betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n    }\n\n    return sampleRate / betterTau;\n  };\n};","\"use strict\";\n\nvar DEFAULT_SAMPLE_RATE = 44100;\nvar MAX_FLWT_LEVELS = 6;\nvar MAX_F = 3000;\nvar DIFFERENCE_LEVELS_N = 3;\nvar MAXIMA_THRESHOLD_RATIO = 0.75;\n\nmodule.exports = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n\n  return function DynamicWaveletDetector(float32AudioBuffer) {\n    \"use strict\";\n\n    var mins = [];\n    var maxs = [];\n    var bufferLength = float32AudioBuffer.length;\n\n    var freq = null;\n    var theDC = 0;\n    var minValue = 0;\n    var maxValue = 0;\n\n    // Compute max amplitude, amplitude threshold, and the DC.\n    for (var i = 0; i < bufferLength; i++) {\n      var sample = float32AudioBuffer[i];\n      theDC = theDC + sample;\n      maxValue = Math.max(maxValue, sample);\n      minValue = Math.min(minValue, sample);\n    }\n\n    theDC /= bufferLength;\n    minValue -= theDC;\n    maxValue -= theDC;\n    var amplitudeMax = maxValue > -1 * minValue ? maxValue : -1 * minValue;\n    var amplitudeThreshold = amplitudeMax * MAXIMA_THRESHOLD_RATIO;\n\n    // levels, start without downsampling...\n    var curLevel = 0;\n    var curModeDistance = -1;\n    var curSamNb = float32AudioBuffer.length;\n    var delta = void 0,\n        nbMaxs = void 0,\n        nbMins = void 0;\n\n    // Search:\n    while (true) {\n      delta = ~~(sampleRate / (Math.pow(2, curLevel) * MAX_F));\n      if (curSamNb < 2) break;\n\n      var dv = void 0;\n      var previousDV = -1000;\n      var lastMinIndex = -1000000;\n      var lastMaxIndex = -1000000;\n      var findMax = false;\n      var findMin = false;\n\n      nbMins = 0;\n      nbMaxs = 0;\n\n      for (var _i = 2; _i < curSamNb; _i++) {\n        var si = float32AudioBuffer[_i] - theDC;\n        var si1 = float32AudioBuffer[_i - 1] - theDC;\n\n        if (si1 <= 0 && si > 0) findMax = true;\n        if (si1 >= 0 && si < 0) findMin = true;\n\n        // min or max ?\n        dv = si - si1;\n\n        if (previousDV > -1000) {\n          if (findMin && previousDV < 0 && dv >= 0) {\n            // minimum\n            if (Math.abs(si) >= amplitudeThreshold) {\n              if (_i > lastMinIndex + delta) {\n                mins[nbMins++] = _i;\n                lastMinIndex = _i;\n                findMin = false;\n              }\n            }\n          }\n\n          if (findMax && previousDV > 0 && dv <= 0) {\n            // maximum\n            if (Math.abs(si) >= amplitudeThreshold) {\n              if (_i > lastMaxIndex + delta) {\n                maxs[nbMaxs++] = _i;\n                lastMaxIndex = _i;\n                findMax = false;\n              }\n            }\n          }\n        }\n        previousDV = dv;\n      }\n\n      if (nbMins === 0 && nbMaxs === 0) {\n        // No best distance found!\n        break;\n      }\n\n      var d = void 0;\n      var distances = [];\n\n      for (var _i2 = 0; _i2 < curSamNb; _i2++) {\n        distances[_i2] = 0;\n      }\n\n      for (var _i3 = 0; _i3 < nbMins; _i3++) {\n        for (var j = 1; j < DIFFERENCE_LEVELS_N; j++) {\n          if (_i3 + j < nbMins) {\n            d = Math.abs(mins[_i3] - mins[_i3 + j]);\n            distances[d] += 1;\n          }\n        }\n      }\n\n      var bestDistance = -1;\n      var bestValue = -1;\n\n      for (var _i4 = 0; _i4 < curSamNb; _i4++) {\n        var summed = 0;\n        for (var _j = -1 * delta; _j <= delta; _j++) {\n          if (_i4 + _j >= 0 && _i4 + _j < curSamNb) {\n            summed += distances[_i4 + _j];\n          }\n        }\n\n        if (summed === bestValue) {\n          if (_i4 === 2 * bestDistance) {\n            bestDistance = _i4;\n          }\n        } else if (summed > bestValue) {\n          bestValue = summed;\n          bestDistance = _i4;\n        }\n      }\n\n      // averaging\n      var distAvg = 0;\n      var nbDists = 0;\n      for (var _j2 = -delta; _j2 <= delta; _j2++) {\n        if (bestDistance + _j2 >= 0 && bestDistance + _j2 < bufferLength) {\n          var nbDist = distances[bestDistance + _j2];\n          if (nbDist > 0) {\n            nbDists += nbDist;\n            distAvg += (bestDistance + _j2) * nbDist;\n          }\n        }\n      }\n\n      // This is our mode distance.\n      distAvg /= nbDists;\n\n      // Continue the levels?\n      if (curModeDistance > -1) {\n        if (Math.abs(distAvg * 2 - curModeDistance) <= 2 * delta) {\n          // two consecutive similar mode distances : ok !\n          freq = sampleRate / (Math.pow(2, curLevel - 1) * curModeDistance);\n          break;\n        }\n      }\n\n      // not similar, continue next level;\n      curModeDistance = distAvg;\n\n      curLevel++;\n      if (curLevel >= MAX_FLWT_LEVELS || curSamNb < 2) {\n        break;\n      }\n\n      //do not modify original audio buffer, make a copy buffer, if\n      //downsampling is needed (only once).\n      var newFloat32AudioBuffer = float32AudioBuffer.subarray(0);\n      if (curSamNb === distances.length) {\n        newFloat32AudioBuffer = new Float32Array(curSamNb / 2);\n      }\n      for (var _i5 = 0; _i5 < curSamNb / 2; _i5++) {\n        newFloat32AudioBuffer[_i5] = (float32AudioBuffer[2 * _i5] + float32AudioBuffer[2 * _i5 + 1]) / 2;\n      }\n      float32AudioBuffer = newFloat32AudioBuffer;\n      curSamNb /= 2;\n    }\n\n    return freq;\n  };\n};","\"use strict\";\n\nmodule.exports = function (config) {\n\n  config = config || {};\n\n  /**\n   * The expected size of an audio buffer (in samples).\n   */\n  var DEFAULT_BUFFER_SIZE = 1024;\n\n  /**\n   * Defines the relative size the chosen peak (pitch) has. 0.93 means: choose\n   * the first peak that is higher than 93% of the highest peak detected. 93%\n   * is the default value used in the Tartini user interface.\n   */\n  var DEFAULT_CUTOFF = 0.97;\n\n  var DEFAULT_SAMPLE_RATE = 44100;\n\n  /**\n   * For performance reasons, peaks below this cutoff are not even considered.\n   */\n  var SMALL_CUTOFF = 0.5;\n\n  /**\n   * Pitch annotations below this threshold are considered invalid, they are\n   * ignored.\n   */\n  var LOWER_PITCH_CUTOFF = 80;\n\n  /**\n   * Defines the relative size the chosen peak (pitch) has.\n   */\n  var cutoff = config.cutoff || DEFAULT_CUTOFF;\n\n  /**\n   * The audio sample rate. Most audio has a sample rate of 44.1kHz.\n   */\n  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n\n  /**\n   * Size of the input buffer.\n   */\n  var bufferSize = config.bufferSize || DEFAULT_BUFFER_SIZE;\n\n  /**\n   * Contains a normalized square difference function value for each delay\n   * (tau).\n   */\n  var nsdf = new Float32Array(bufferSize);\n\n  /**\n   * Contains a sum of squares of the Buffer, for improving performance\n   * (avoids redoing math in the normalized square difference function)\n   */\n  var squaredBufferSum = new Float32Array(bufferSize);\n\n  /**\n   * The x and y coordinate of the top of the curve (nsdf).\n   */\n  var turningPointX = void 0;\n  var turningPointY = void 0;\n\n  /**\n   * A list with minimum and maximum values of the nsdf curve.\n   */\n  var maxPositions = [];\n\n  /**\n   * A list of estimates of the period of the signal (in samples).\n   */\n  var periodEstimates = [];\n\n  /**\n   * A list of estimates of the amplitudes corresponding with the period\n   * estimates.\n   */\n  var ampEstimates = [];\n\n  /**\n   * The result of the pitch detection iteration.\n   */\n  var result = {};\n\n  /**\n   * Implements the normalized square difference function. See section 4 (and\n   * the explanation before) in the MPM article. This calculation can be\n   * optimized by using an FFT. The results should remain the same.\n   */\n  var normalizedSquareDifference = function normalizedSquareDifference(float32AudioBuffer) {\n    var acf = void 0;\n    var divisorM = void 0;\n    squaredBufferSum[0] = float32AudioBuffer[0] * float32AudioBuffer[0];\n    for (var i = 1; i < float32AudioBuffer.length; i += 1) {\n      squaredBufferSum[i] = float32AudioBuffer[i] * float32AudioBuffer[i] + squaredBufferSum[i - 1];\n    }\n    for (var tau = 0; tau < float32AudioBuffer.length; tau++) {\n      acf = 0;\n      divisorM = squaredBufferSum[float32AudioBuffer.length - 1 - tau] + squaredBufferSum[float32AudioBuffer.length - 1] - squaredBufferSum[tau];\n      for (var _i = 0; _i < float32AudioBuffer.length - tau; _i++) {\n        acf += float32AudioBuffer[_i] * float32AudioBuffer[_i + tau];\n      }\n      nsdf[tau] = 2 * acf / divisorM;\n    }\n  };\n\n  /**\n   * Finds the x value corresponding with the peak of a parabola.\n   * Interpolates between three consecutive points centered on tau.\n   */\n  var parabolicInterpolation = function parabolicInterpolation(tau) {\n    var nsdfa = nsdf[tau - 1],\n        nsdfb = nsdf[tau],\n        nsdfc = nsdf[tau + 1],\n        bValue = tau,\n        bottom = nsdfc + nsdfa - 2 * nsdfb;\n    if (bottom === 0) {\n      turningPointX = bValue;\n      turningPointY = nsdfb;\n    } else {\n      var delta = nsdfa - nsdfc;\n      turningPointX = bValue + delta / (2 * bottom);\n      turningPointY = nsdfb - delta * delta / (8 * bottom);\n    }\n  };\n\n  // Finds the highest value between each pair of positive zero crossings.\n  var peakPicking = function peakPicking() {\n    var pos = 0;\n    var curMaxPos = 0;\n\n    // find the first negative zero crossing.\n    while (pos < (nsdf.length - 1) / 3 && nsdf[pos] > 0) {\n      pos++;\n    }\n\n    // loop over all the values below zero.\n    while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n      pos++;\n    }\n\n    // can happen if output[0] is NAN\n    if (pos == 0) {\n      pos = 1;\n    }\n\n    while (pos < nsdf.length - 1) {\n      if (nsdf[pos] > nsdf[pos - 1] && nsdf[pos] >= nsdf[pos + 1]) {\n        if (curMaxPos == 0) {\n          // the first max (between zero crossings)\n          curMaxPos = pos;\n        } else if (nsdf[pos] > nsdf[curMaxPos]) {\n          // a higher max (between the zero crossings)\n          curMaxPos = pos;\n        }\n      }\n      pos++;\n      // a negative zero crossing\n      if (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n        // if there was a maximum add it to the list of maxima\n        if (curMaxPos > 0) {\n          maxPositions.push(curMaxPos);\n          curMaxPos = 0; // clear the maximum position, so we start\n          // looking for a new ones\n        }\n        while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n          pos++; // loop over all the values below zero\n        }\n      }\n    }\n    if (curMaxPos > 0) {\n      maxPositions.push(curMaxPos);\n    }\n  };\n\n  return function (float32AudioBuffer) {\n\n    // 0. Clear old results.\n    var pitch = void 0;\n    maxPositions = [];\n    periodEstimates = [];\n    ampEstimates = [];\n\n    // 1. Calculute the normalized square difference for each Tau value.\n    normalizedSquareDifference(float32AudioBuffer);\n    // 2. Peak picking time: time to pick some peaks.\n    peakPicking();\n\n    var highestAmplitude = -Infinity;\n\n    for (var i = 0; i < maxPositions.length; i++) {\n      var tau = maxPositions[i];\n      // make sure every annotation has a probability attached\n      highestAmplitude = Math.max(highestAmplitude, nsdf[tau]);\n\n      if (nsdf[tau] > SMALL_CUTOFF) {\n        // calculates turningPointX and Y\n        parabolicInterpolation(tau);\n        // store the turning points\n        ampEstimates.push(turningPointY);\n        periodEstimates.push(turningPointX);\n        // remember the highest amplitude\n        highestAmplitude = Math.max(highestAmplitude, turningPointY);\n      }\n    }\n\n    if (periodEstimates.length) {\n      // use the overall maximum to calculate a cutoff.\n      // The cutoff value is based on the highest value and a relative\n      // threshold.\n      var actualCutoff = cutoff * highestAmplitude;\n      var periodIndex = 0;\n\n      for (var _i2 = 0; _i2 < ampEstimates.length; _i2++) {\n        if (ampEstimates[_i2] >= actualCutoff) {\n          periodIndex = _i2;\n          break;\n        }\n      }\n\n      var period = periodEstimates[periodIndex],\n          pitchEstimate = sampleRate / period;\n\n      if (pitchEstimate > LOWER_PITCH_CUTOFF) {\n        pitch = pitchEstimate;\n      } else {\n        pitch = -1;\n      }\n    } else {\n      // no pitch detected.\n      pitch = -1;\n    }\n\n    result.probability = highestAmplitude;\n    result.freq = pitch;\n    return result;\n  };\n};","\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar DEFAULT_TEMPO = 120;\nvar DEFAULT_QUANTIZATION = 4;\nvar DEFAULT_SAMPLE_RATE = 44100;\n\nfunction pitchConsensus(detectors, chunk) {\n  var pitches = detectors.map(function (fn) {\n    return fn(chunk);\n  }).filter(Boolean).sort(function (a, b) {\n    return a < b ? -1 : 1;\n  });\n\n  // In the case of one pitch, return it.\n  if (pitches.length === 1) {\n    return pitches[0];\n\n    // In the case of two pitches, return the geometric mean if they\n    // are close to each other, and the lower pitch otherwise.\n  } else if (pitches.length === 2) {\n    var _pitches = _slicedToArray(pitches, 2),\n        first = _pitches[0],\n        second = _pitches[1];\n\n    return first * 2 > second ? Math.sqrt(first * second) : first;\n\n    // In the case of three or more pitches, filter away the extremes\n    // if they are very extreme, then take the geometric mean. \n  } else {\n    var _first = pitches[0];\n    var _second = pitches[1];\n    var secondToLast = pitches[pitches.length - 2];\n    var last = pitches[pitches.length - 1];\n\n    var filtered1 = _first * 2 > _second ? pitches : pitches.slice(1);\n    var filtered2 = secondToLast * 2 > last ? filtered1 : filtered1.slice(0, -1);\n    return Math.pow(filtered2.reduce(function (t, p) {\n      return t * p;\n    }, 1), 1 / filtered2.length);\n  }\n}\n\nmodule.exports = function (detector, float32AudioBuffer) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\n  var tempo = options.tempo || DEFAULT_TEMPO;\n  var quantization = options.quantization || DEFAULT_QUANTIZATION;\n  var sampleRate = options.sampleRate || DEFAULT_SAMPLE_RATE;\n\n  var bufferLength = float32AudioBuffer.length;\n  var chunkSize = Math.round(sampleRate * 60 / (quantization * tempo));\n\n  var getPitch = void 0;\n  if (Array.isArray(detector)) {\n    getPitch = pitchConsensus.bind(null, detector);\n  } else {\n    getPitch = detector;\n  }\n\n  var pitches = [];\n  for (var i = 0, max = bufferLength - chunkSize; i <= max; i += chunkSize) {\n    var chunk = float32AudioBuffer.slice(i, i + chunkSize);\n    var pitch = getPitch(chunk);\n    pitches.push(pitch);\n  }\n\n  return pitches;\n};","\"use strict\";\n\nvar AMDF = require(\"./detectors/amdf\");\nvar YIN = require(\"./detectors/yin\");\nvar DynamicWavelet = require(\"./detectors/dynamic_wavelet\");\nvar Macleod = require(\"./detectors/macleod\");\n\nvar frequencies = require(\"./tools/frequencies\");\n\nmodule.exports = {\n  AMDF: AMDF,\n  YIN: YIN,\n  DynamicWavelet: DynamicWavelet,\n  Macleod: Macleod,\n  frequencies: frequencies\n};","module.exports = require(\"./lib\");","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","const Pitchfinder = require(\"pitchfinder\");\nconst detectPitch = Pitchfinder.AMDF();\n\nlet lastFrequency = null;\n\nexports.onFrequencyChange = async f => {\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n  const context = new window.AudioContext();\n  const analyser = context.createAnalyser();\n  const processor = context.createScriptProcessor(4096, 1, 1);\n  const audioSource = context.createMediaStreamSource(stream);\n  const process = event => {\n    const frequency = detectPitch(event.inputBuffer.getChannelData(0));\n\n    if (frequency !== lastFrequency) {\n      lastFrequency = frequency;\n      f(frequency);\n    }\n  };\n\n  audioSource.connect(analyser);\n  analyser.connect(processor);\n  processor.connect(context.destination);\n  processor.addEventListener(\"audioprocess\", process);\n\n  return () => {\n    processor.removeEventListener(\"audioprocess\", process);\n    stream.getTracks().forEach(track => track.stop());\n    processor.disconnect();\n    analyser.disconnect();\n    audioSource.disconnect();\n    context.close();\n  };\n};\n","const { onFrequencyChange } = require(\"./audio\");\nconst { Elm } = require(\"./Main.elm\");\n\nconst app = Elm.Main.init({\n  flags: {},\n  node: document.querySelector(\"main#elm\")\n});\n\nlet audio;\n\napp.ports.startListeningForFrequencyChanges.subscribe(() => {\n  audio = onFrequencyChange(frequency => {\n    app.ports.onFrequencyChange.send(frequency);\n  });\n});\n\napp.ports.stopListeningForFrequencyChanges.subscribe(() => {\n  audio && audio.then(disconnect => disconnect());\n});\n"]}