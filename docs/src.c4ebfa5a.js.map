{"version":3,"sources":["../node_modules/pitchfinder/lib/detectors/amdf.js","../node_modules/pitchfinder/lib/detectors/yin.js","../node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js","../node_modules/pitchfinder/lib/detectors/macleod.js","../node_modules/pitchfinder/lib/tools/frequencies.js","../node_modules/pitchfinder/lib/index.js","../node_modules/pitchfinder/index.js","../node_modules/process/browser.js","audio.js","index.js"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","Pitchfinder","require","detectPitch","AMDF","lastFrequency","onFrequencyChange","stream","navigator","mediaDevices","getUserMedia","audio","context","window","AudioContext","analyser","createAnalyser","processor","createScriptProcessor","audioSource","createMediaStreamSource","event","frequency","inputBuffer","getChannelData","f","connect","destination","addEventListener","removeEventListener","getTracks","forEach","track","stop","disconnect","close","Elm","app","Main","init","flags","node","document","querySelector","ports","startListeningForFrequencyChanges","subscribe","send","stopListeningForFrequencyChanges","then"],"mappings":"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","file":"src.c4ebfa5a.js","sourceRoot":"../src","sourcesContent":["\"use strict\";\n\nvar DEFAULT_MIN_FREQUENCY = 82;\nvar DEFAULT_MAX_FREQUENCY = 1000;\nvar DEFAULT_RATIO = 5;\nvar DEFAULT_SENSITIVITY = 0.1;\nvar DEFAULT_SAMPLE_RATE = 44100;\n\nmodule.exports = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n  var minFrequency = config.minFrequency || DEFAULT_MIN_FREQUENCY;\n  var maxFrequency = config.maxFrequency || DEFAULT_MAX_FREQUENCY;\n  var sensitivity = config.sensitivity || DEFAULT_SENSITIVITY;\n  var ratio = config.ratio || DEFAULT_RATIO;\n  var amd = [];\n\n  /* Round in such a way that both exact minPeriod as \n   exact maxPeriod lie inside the rounded span minPeriod-maxPeriod,\n   thus ensuring that minFrequency and maxFrequency can be found\n   even in edge cases */\n  var maxPeriod = Math.ceil(sampleRate / minFrequency);\n  var minPeriod = Math.floor(sampleRate / maxFrequency);\n\n  return function AMDFDetector(float32AudioBuffer) {\n    \"use strict\";\n\n    var maxShift = float32AudioBuffer.length;\n\n    var t = 0;\n    var minval = Infinity;\n    var maxval = -Infinity;\n    var frames1 = void 0,\n        frames2 = void 0,\n        calcSub = void 0,\n        i = void 0,\n        j = void 0,\n        u = void 0,\n        aux1 = void 0,\n        aux2 = void 0;\n\n    // Find the average magnitude difference for each possible period offset.\n    for (i = 0; i < maxShift; i++) {\n      if (minPeriod <= i && i <= maxPeriod) {\n        for (aux1 = 0, aux2 = i, t = 0, frames1 = [], frames2 = []; aux1 < maxShift - i; t++, aux2++, aux1++) {\n          frames1[t] = float32AudioBuffer[aux1];\n          frames2[t] = float32AudioBuffer[aux2];\n        }\n\n        // Take the difference between these frames.\n        var frameLength = frames1.length;\n        calcSub = [];\n        for (u = 0; u < frameLength; u++) {\n          calcSub[u] = frames1[u] - frames2[u];\n        }\n\n        // Sum the differences.\n        var summation = 0;\n        for (u = 0; u < frameLength; u++) {\n          summation += Math.abs(calcSub[u]);\n        }\n        amd[i] = summation;\n      }\n    }\n\n    for (j = minPeriod; j < maxPeriod; j++) {\n      if (amd[j] < minval) minval = amd[j];\n      if (amd[j] > maxval) maxval = amd[j];\n    }\n\n    var cutoff = Math.round(sensitivity * (maxval - minval) + minval);\n    for (j = minPeriod; j <= maxPeriod && amd[j] > cutoff; j++) {}\n\n    var search_length = minPeriod / 2;\n    minval = amd[j];\n    var minpos = j;\n    for (i = j - 1; i < j + search_length && i <= maxPeriod; i++) {\n      if (amd[i] < minval) {\n        minval = amd[i];\n        minpos = i;\n      }\n    }\n\n    if (Math.round(amd[minpos] * ratio) < maxval) {\n      return sampleRate / minpos;\n    } else {\n      return null;\n    }\n  };\n};","\"use strict\";\n\n/*\n  Copyright (C) 2003-2009 Paul Brossier <piem@aubio.org>\n  This file is part of aubio.\n  aubio is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  aubio is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n  along with aubio.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* This algorithm was developed by A. de Cheveigné and H. Kawahara and\n * published in:\n * \n * de Cheveigné, A., Kawahara, H. (2002) \"YIN, a fundamental frequency\n * estimator for speech and music\", J. Acoust. Soc. Am. 111, 1917-1930.  \n *\n * see http://recherche.ircam.fr/equipes/pcm/pub/people/cheveign.html\n */\n\nvar DEFAULT_THRESHOLD = 0.10;\nvar DEFAULT_SAMPLE_RATE = 44100;\nvar DEFAULT_PROBABILITY_THRESHOLD = 0.1;\n\nmodule.exports = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n  var threshold = config.threshold || DEFAULT_THRESHOLD;\n  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n  var probabilityThreshold = config.probabilityThreshold || DEFAULT_PROBABILITY_THRESHOLD;\n\n  return function YINDetector(float32AudioBuffer) {\n    \"use strict\";\n\n    // Set buffer size to the highest power of two below the provided buffer's length.\n\n    var bufferSize = void 0;\n    for (bufferSize = 1; bufferSize < float32AudioBuffer.length; bufferSize *= 2) {}\n    bufferSize /= 2;\n\n    // Set up the yinBuffer as described in step one of the YIN paper.\n    var yinBufferLength = bufferSize / 2;\n    var yinBuffer = new Float32Array(yinBufferLength);\n\n    var probability = void 0,\n        tau = void 0;\n\n    // Compute the difference function as described in step 2 of the YIN paper.\n    for (var t = 0; t < yinBufferLength; t++) {\n      yinBuffer[t] = 0;\n    }\n    for (var _t = 1; _t < yinBufferLength; _t++) {\n      for (var i = 0; i < yinBufferLength; i++) {\n        var delta = float32AudioBuffer[i] - float32AudioBuffer[i + _t];\n        yinBuffer[_t] += delta * delta;\n      }\n    }\n\n    // Compute the cumulative mean normalized difference as described in step 3 of the paper.\n    yinBuffer[0] = 1;\n    yinBuffer[1] = 1;\n    var runningSum = 0;\n    for (var _t2 = 1; _t2 < yinBufferLength; _t2++) {\n      runningSum += yinBuffer[_t2];\n      yinBuffer[_t2] *= _t2 / runningSum;\n    }\n\n    // Compute the absolute threshold as described in step 4 of the paper.\n    // Since the first two positions in the array are 1,\n    // we can start at the third position.\n    for (tau = 2; tau < yinBufferLength; tau++) {\n      if (yinBuffer[tau] < threshold) {\n        while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n          tau++;\n        }\n        // found tau, exit loop and return\n        // store the probability\n        // From the YIN paper: The threshold determines the list of\n        // candidates admitted to the set, and can be interpreted as the\n        // proportion of aperiodic power tolerated\n        // within a periodic signal.\n        //\n        // Since we want the periodicity and and not aperiodicity:\n        // periodicity = 1 - aperiodicity\n        probability = 1 - yinBuffer[tau];\n        break;\n      }\n    }\n\n    // if no pitch found, return null.\n    if (tau == yinBufferLength || yinBuffer[tau] >= threshold) {\n      return null;\n    }\n\n    // If probability too low, return -1.\n    if (probability < probabilityThreshold) {\n      return null;\n    }\n\n    /**\n     * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n     * value using parabolic interpolation. This is needed to detect higher\n     * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n     * for more background\n     * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n     */\n    var betterTau = void 0,\n        x0 = void 0,\n        x2 = void 0;\n    if (tau < 1) {\n      x0 = tau;\n    } else {\n      x0 = tau - 1;\n    }\n    if (tau + 1 < yinBufferLength) {\n      x2 = tau + 1;\n    } else {\n      x2 = tau;\n    }\n    if (x0 === tau) {\n      if (yinBuffer[tau] <= yinBuffer[x2]) {\n        betterTau = tau;\n      } else {\n        betterTau = x2;\n      }\n    } else if (x2 === tau) {\n      if (yinBuffer[tau] <= yinBuffer[x0]) {\n        betterTau = tau;\n      } else {\n        betterTau = x0;\n      }\n    } else {\n      var s0 = yinBuffer[x0];\n      var s1 = yinBuffer[tau];\n      var s2 = yinBuffer[x2];\n      // fixed AUBIO implementation, thanks to Karl Helgason:\n      // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n      betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n    }\n\n    return sampleRate / betterTau;\n  };\n};","\"use strict\";\n\nvar DEFAULT_SAMPLE_RATE = 44100;\nvar MAX_FLWT_LEVELS = 6;\nvar MAX_F = 3000;\nvar DIFFERENCE_LEVELS_N = 3;\nvar MAXIMA_THRESHOLD_RATIO = 0.75;\n\nmodule.exports = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n\n  return function DynamicWaveletDetector(float32AudioBuffer) {\n    \"use strict\";\n\n    var mins = [];\n    var maxs = [];\n    var bufferLength = float32AudioBuffer.length;\n\n    var freq = null;\n    var theDC = 0;\n    var minValue = 0;\n    var maxValue = 0;\n\n    // Compute max amplitude, amplitude threshold, and the DC.\n    for (var i = 0; i < bufferLength; i++) {\n      var sample = float32AudioBuffer[i];\n      theDC = theDC + sample;\n      maxValue = Math.max(maxValue, sample);\n      minValue = Math.min(minValue, sample);\n    }\n\n    theDC /= bufferLength;\n    minValue -= theDC;\n    maxValue -= theDC;\n    var amplitudeMax = maxValue > -1 * minValue ? maxValue : -1 * minValue;\n    var amplitudeThreshold = amplitudeMax * MAXIMA_THRESHOLD_RATIO;\n\n    // levels, start without downsampling...\n    var curLevel = 0;\n    var curModeDistance = -1;\n    var curSamNb = float32AudioBuffer.length;\n    var delta = void 0,\n        nbMaxs = void 0,\n        nbMins = void 0;\n\n    // Search:\n    while (true) {\n      delta = ~~(sampleRate / (Math.pow(2, curLevel) * MAX_F));\n      if (curSamNb < 2) break;\n\n      var dv = void 0;\n      var previousDV = -1000;\n      var lastMinIndex = -1000000;\n      var lastMaxIndex = -1000000;\n      var findMax = false;\n      var findMin = false;\n\n      nbMins = 0;\n      nbMaxs = 0;\n\n      for (var _i = 2; _i < curSamNb; _i++) {\n        var si = float32AudioBuffer[_i] - theDC;\n        var si1 = float32AudioBuffer[_i - 1] - theDC;\n\n        if (si1 <= 0 && si > 0) findMax = true;\n        if (si1 >= 0 && si < 0) findMin = true;\n\n        // min or max ?\n        dv = si - si1;\n\n        if (previousDV > -1000) {\n          if (findMin && previousDV < 0 && dv >= 0) {\n            // minimum\n            if (Math.abs(si) >= amplitudeThreshold) {\n              if (_i > lastMinIndex + delta) {\n                mins[nbMins++] = _i;\n                lastMinIndex = _i;\n                findMin = false;\n              }\n            }\n          }\n\n          if (findMax && previousDV > 0 && dv <= 0) {\n            // maximum\n            if (Math.abs(si) >= amplitudeThreshold) {\n              if (_i > lastMaxIndex + delta) {\n                maxs[nbMaxs++] = _i;\n                lastMaxIndex = _i;\n                findMax = false;\n              }\n            }\n          }\n        }\n        previousDV = dv;\n      }\n\n      if (nbMins === 0 && nbMaxs === 0) {\n        // No best distance found!\n        break;\n      }\n\n      var d = void 0;\n      var distances = [];\n\n      for (var _i2 = 0; _i2 < curSamNb; _i2++) {\n        distances[_i2] = 0;\n      }\n\n      for (var _i3 = 0; _i3 < nbMins; _i3++) {\n        for (var j = 1; j < DIFFERENCE_LEVELS_N; j++) {\n          if (_i3 + j < nbMins) {\n            d = Math.abs(mins[_i3] - mins[_i3 + j]);\n            distances[d] += 1;\n          }\n        }\n      }\n\n      var bestDistance = -1;\n      var bestValue = -1;\n\n      for (var _i4 = 0; _i4 < curSamNb; _i4++) {\n        var summed = 0;\n        for (var _j = -1 * delta; _j <= delta; _j++) {\n          if (_i4 + _j >= 0 && _i4 + _j < curSamNb) {\n            summed += distances[_i4 + _j];\n          }\n        }\n\n        if (summed === bestValue) {\n          if (_i4 === 2 * bestDistance) {\n            bestDistance = _i4;\n          }\n        } else if (summed > bestValue) {\n          bestValue = summed;\n          bestDistance = _i4;\n        }\n      }\n\n      // averaging\n      var distAvg = 0;\n      var nbDists = 0;\n      for (var _j2 = -delta; _j2 <= delta; _j2++) {\n        if (bestDistance + _j2 >= 0 && bestDistance + _j2 < bufferLength) {\n          var nbDist = distances[bestDistance + _j2];\n          if (nbDist > 0) {\n            nbDists += nbDist;\n            distAvg += (bestDistance + _j2) * nbDist;\n          }\n        }\n      }\n\n      // This is our mode distance.\n      distAvg /= nbDists;\n\n      // Continue the levels?\n      if (curModeDistance > -1) {\n        if (Math.abs(distAvg * 2 - curModeDistance) <= 2 * delta) {\n          // two consecutive similar mode distances : ok !\n          freq = sampleRate / (Math.pow(2, curLevel - 1) * curModeDistance);\n          break;\n        }\n      }\n\n      // not similar, continue next level;\n      curModeDistance = distAvg;\n\n      curLevel++;\n      if (curLevel >= MAX_FLWT_LEVELS || curSamNb < 2) {\n        break;\n      }\n\n      //do not modify original audio buffer, make a copy buffer, if\n      //downsampling is needed (only once).\n      var newFloat32AudioBuffer = float32AudioBuffer.subarray(0);\n      if (curSamNb === distances.length) {\n        newFloat32AudioBuffer = new Float32Array(curSamNb / 2);\n      }\n      for (var _i5 = 0; _i5 < curSamNb / 2; _i5++) {\n        newFloat32AudioBuffer[_i5] = (float32AudioBuffer[2 * _i5] + float32AudioBuffer[2 * _i5 + 1]) / 2;\n      }\n      float32AudioBuffer = newFloat32AudioBuffer;\n      curSamNb /= 2;\n    }\n\n    return freq;\n  };\n};","\"use strict\";\n\nmodule.exports = function (config) {\n\n  config = config || {};\n\n  /**\n   * The expected size of an audio buffer (in samples).\n   */\n  var DEFAULT_BUFFER_SIZE = 1024;\n\n  /**\n   * Defines the relative size the chosen peak (pitch) has. 0.93 means: choose\n   * the first peak that is higher than 93% of the highest peak detected. 93%\n   * is the default value used in the Tartini user interface.\n   */\n  var DEFAULT_CUTOFF = 0.97;\n\n  var DEFAULT_SAMPLE_RATE = 44100;\n\n  /**\n   * For performance reasons, peaks below this cutoff are not even considered.\n   */\n  var SMALL_CUTOFF = 0.5;\n\n  /**\n   * Pitch annotations below this threshold are considered invalid, they are\n   * ignored.\n   */\n  var LOWER_PITCH_CUTOFF = 80;\n\n  /**\n   * Defines the relative size the chosen peak (pitch) has.\n   */\n  var cutoff = config.cutoff || DEFAULT_CUTOFF;\n\n  /**\n   * The audio sample rate. Most audio has a sample rate of 44.1kHz.\n   */\n  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n\n  /**\n   * Size of the input buffer.\n   */\n  var bufferSize = config.bufferSize || DEFAULT_BUFFER_SIZE;\n\n  /**\n   * Contains a normalized square difference function value for each delay\n   * (tau).\n   */\n  var nsdf = new Float32Array(bufferSize);\n\n  /**\n   * Contains a sum of squares of the Buffer, for improving performance\n   * (avoids redoing math in the normalized square difference function)\n   */\n  var squaredBufferSum = new Float32Array(bufferSize);\n\n  /**\n   * The x and y coordinate of the top of the curve (nsdf).\n   */\n  var turningPointX = void 0;\n  var turningPointY = void 0;\n\n  /**\n   * A list with minimum and maximum values of the nsdf curve.\n   */\n  var maxPositions = [];\n\n  /**\n   * A list of estimates of the period of the signal (in samples).\n   */\n  var periodEstimates = [];\n\n  /**\n   * A list of estimates of the amplitudes corresponding with the period\n   * estimates.\n   */\n  var ampEstimates = [];\n\n  /**\n   * The result of the pitch detection iteration.\n   */\n  var result = {};\n\n  /**\n   * Implements the normalized square difference function. See section 4 (and\n   * the explanation before) in the MPM article. This calculation can be\n   * optimized by using an FFT. The results should remain the same.\n   */\n  var normalizedSquareDifference = function normalizedSquareDifference(float32AudioBuffer) {\n    var acf = void 0;\n    var divisorM = void 0;\n    squaredBufferSum[0] = float32AudioBuffer[0] * float32AudioBuffer[0];\n    for (var i = 1; i < float32AudioBuffer.length; i += 1) {\n      squaredBufferSum[i] = float32AudioBuffer[i] * float32AudioBuffer[i] + squaredBufferSum[i - 1];\n    }\n    for (var tau = 0; tau < float32AudioBuffer.length; tau++) {\n      acf = 0;\n      divisorM = squaredBufferSum[float32AudioBuffer.length - 1 - tau] + squaredBufferSum[float32AudioBuffer.length - 1] - squaredBufferSum[tau];\n      for (var _i = 0; _i < float32AudioBuffer.length - tau; _i++) {\n        acf += float32AudioBuffer[_i] * float32AudioBuffer[_i + tau];\n      }\n      nsdf[tau] = 2 * acf / divisorM;\n    }\n  };\n\n  /**\n   * Finds the x value corresponding with the peak of a parabola.\n   * Interpolates between three consecutive points centered on tau.\n   */\n  var parabolicInterpolation = function parabolicInterpolation(tau) {\n    var nsdfa = nsdf[tau - 1],\n        nsdfb = nsdf[tau],\n        nsdfc = nsdf[tau + 1],\n        bValue = tau,\n        bottom = nsdfc + nsdfa - 2 * nsdfb;\n    if (bottom === 0) {\n      turningPointX = bValue;\n      turningPointY = nsdfb;\n    } else {\n      var delta = nsdfa - nsdfc;\n      turningPointX = bValue + delta / (2 * bottom);\n      turningPointY = nsdfb - delta * delta / (8 * bottom);\n    }\n  };\n\n  // Finds the highest value between each pair of positive zero crossings.\n  var peakPicking = function peakPicking() {\n    var pos = 0;\n    var curMaxPos = 0;\n\n    // find the first negative zero crossing.\n    while (pos < (nsdf.length - 1) / 3 && nsdf[pos] > 0) {\n      pos++;\n    }\n\n    // loop over all the values below zero.\n    while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n      pos++;\n    }\n\n    // can happen if output[0] is NAN\n    if (pos == 0) {\n      pos = 1;\n    }\n\n    while (pos < nsdf.length - 1) {\n      if (nsdf[pos] > nsdf[pos - 1] && nsdf[pos] >= nsdf[pos + 1]) {\n        if (curMaxPos == 0) {\n          // the first max (between zero crossings)\n          curMaxPos = pos;\n        } else if (nsdf[pos] > nsdf[curMaxPos]) {\n          // a higher max (between the zero crossings)\n          curMaxPos = pos;\n        }\n      }\n      pos++;\n      // a negative zero crossing\n      if (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n        // if there was a maximum add it to the list of maxima\n        if (curMaxPos > 0) {\n          maxPositions.push(curMaxPos);\n          curMaxPos = 0; // clear the maximum position, so we start\n          // looking for a new ones\n        }\n        while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n          pos++; // loop over all the values below zero\n        }\n      }\n    }\n    if (curMaxPos > 0) {\n      maxPositions.push(curMaxPos);\n    }\n  };\n\n  return function (float32AudioBuffer) {\n\n    // 0. Clear old results.\n    var pitch = void 0;\n    maxPositions = [];\n    periodEstimates = [];\n    ampEstimates = [];\n\n    // 1. Calculute the normalized square difference for each Tau value.\n    normalizedSquareDifference(float32AudioBuffer);\n    // 2. Peak picking time: time to pick some peaks.\n    peakPicking();\n\n    var highestAmplitude = -Infinity;\n\n    for (var i = 0; i < maxPositions.length; i++) {\n      var tau = maxPositions[i];\n      // make sure every annotation has a probability attached\n      highestAmplitude = Math.max(highestAmplitude, nsdf[tau]);\n\n      if (nsdf[tau] > SMALL_CUTOFF) {\n        // calculates turningPointX and Y\n        parabolicInterpolation(tau);\n        // store the turning points\n        ampEstimates.push(turningPointY);\n        periodEstimates.push(turningPointX);\n        // remember the highest amplitude\n        highestAmplitude = Math.max(highestAmplitude, turningPointY);\n      }\n    }\n\n    if (periodEstimates.length) {\n      // use the overall maximum to calculate a cutoff.\n      // The cutoff value is based on the highest value and a relative\n      // threshold.\n      var actualCutoff = cutoff * highestAmplitude;\n      var periodIndex = 0;\n\n      for (var _i2 = 0; _i2 < ampEstimates.length; _i2++) {\n        if (ampEstimates[_i2] >= actualCutoff) {\n          periodIndex = _i2;\n          break;\n        }\n      }\n\n      var period = periodEstimates[periodIndex],\n          pitchEstimate = sampleRate / period;\n\n      if (pitchEstimate > LOWER_PITCH_CUTOFF) {\n        pitch = pitchEstimate;\n      } else {\n        pitch = -1;\n      }\n    } else {\n      // no pitch detected.\n      pitch = -1;\n    }\n\n    result.probability = highestAmplitude;\n    result.freq = pitch;\n    return result;\n  };\n};","\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar DEFAULT_TEMPO = 120;\nvar DEFAULT_QUANTIZATION = 4;\nvar DEFAULT_SAMPLE_RATE = 44100;\n\nfunction pitchConsensus(detectors, chunk) {\n  var pitches = detectors.map(function (fn) {\n    return fn(chunk);\n  }).filter(Boolean).sort(function (a, b) {\n    return a < b ? -1 : 1;\n  });\n\n  // In the case of one pitch, return it.\n  if (pitches.length === 1) {\n    return pitches[0];\n\n    // In the case of two pitches, return the geometric mean if they\n    // are close to each other, and the lower pitch otherwise.\n  } else if (pitches.length === 2) {\n    var _pitches = _slicedToArray(pitches, 2),\n        first = _pitches[0],\n        second = _pitches[1];\n\n    return first * 2 > second ? Math.sqrt(first * second) : first;\n\n    // In the case of three or more pitches, filter away the extremes\n    // if they are very extreme, then take the geometric mean. \n  } else {\n    var _first = pitches[0];\n    var _second = pitches[1];\n    var secondToLast = pitches[pitches.length - 2];\n    var last = pitches[pitches.length - 1];\n\n    var filtered1 = _first * 2 > _second ? pitches : pitches.slice(1);\n    var filtered2 = secondToLast * 2 > last ? filtered1 : filtered1.slice(0, -1);\n    return Math.pow(filtered2.reduce(function (t, p) {\n      return t * p;\n    }, 1), 1 / filtered2.length);\n  }\n}\n\nmodule.exports = function (detector, float32AudioBuffer) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\n  var tempo = options.tempo || DEFAULT_TEMPO;\n  var quantization = options.quantization || DEFAULT_QUANTIZATION;\n  var sampleRate = options.sampleRate || DEFAULT_SAMPLE_RATE;\n\n  var bufferLength = float32AudioBuffer.length;\n  var chunkSize = Math.round(sampleRate * 60 / (quantization * tempo));\n\n  var getPitch = void 0;\n  if (Array.isArray(detector)) {\n    getPitch = pitchConsensus.bind(null, detector);\n  } else {\n    getPitch = detector;\n  }\n\n  var pitches = [];\n  for (var i = 0, max = bufferLength - chunkSize; i <= max; i += chunkSize) {\n    var chunk = float32AudioBuffer.slice(i, i + chunkSize);\n    var pitch = getPitch(chunk);\n    pitches.push(pitch);\n  }\n\n  return pitches;\n};","\"use strict\";\n\nvar AMDF = require(\"./detectors/amdf\");\nvar YIN = require(\"./detectors/yin\");\nvar DynamicWavelet = require(\"./detectors/dynamic_wavelet\");\nvar Macleod = require(\"./detectors/macleod\");\n\nvar frequencies = require(\"./tools/frequencies\");\n\nmodule.exports = {\n  AMDF: AMDF,\n  YIN: YIN,\n  DynamicWavelet: DynamicWavelet,\n  Macleod: Macleod,\n  frequencies: frequencies\n};","module.exports = require(\"./lib\");","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","const Pitchfinder = require(\"pitchfinder\");\nconst detectPitch = Pitchfinder.AMDF();\n\nlet lastFrequency = null;\n\nexports.onFrequencyChange = async f => {\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n  const context = new window.AudioContext();\n  const analyser = context.createAnalyser();\n  const processor = context.createScriptProcessor(4096, 1, 1);\n  const audioSource = context.createMediaStreamSource(stream);\n  const process = event => {\n    const frequency = detectPitch(event.inputBuffer.getChannelData(0));\n\n    if (frequency !== lastFrequency) {\n      lastFrequency = frequency;\n      f(frequency);\n    }\n  };\n\n  audioSource.connect(analyser);\n  analyser.connect(processor);\n  processor.connect(context.destination);\n  processor.addEventListener(\"audioprocess\", process);\n\n  return () => {\n    processor.removeEventListener(\"audioprocess\", process);\n    stream.getTracks().forEach(track => track.stop());\n    processor.disconnect();\n    analyser.disconnect();\n    audioSource.disconnect();\n    context.close();\n  };\n};\n","const { onFrequencyChange } = require(\"./audio\");\nconst { Elm } = require(\"./Main.elm\");\n\nconst app = Elm.Main.init({\n  flags: {},\n  node: document.querySelector(\"main#elm\")\n});\n\nlet audio;\n\napp.ports.startListeningForFrequencyChanges.subscribe(() => {\n  audio = onFrequencyChange(frequency => {\n    app.ports.onFrequencyChange.send(frequency);\n  });\n});\n\napp.ports.stopListeningForFrequencyChanges.subscribe(() => {\n  audio && audio.then(disconnect => disconnect());\n});\n"]}